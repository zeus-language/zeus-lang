use core::libc;
fn panic(msg : *u8) : void {
    printf("Panic: %s\n" as *u8, msg);
    exit(1);
}
struct array<T>{
    length : i64,
    capacity : i64,
    data : *T,

    fn length(self: &array<T>) : i64 {
        return self.length;
    }

    fn push(self: mut &array<T>,value : T) : void {
        let size_of_t : i64 = sizeof<T>();
        if self.length >= self.capacity {
            // Resize logic (simple doubling strategy)
            let mut new_capacity : i64;
            if self.capacity == 0 as i64 {
                new_capacity = 1 as i64;
            }
            else {
                new_capacity = self.capacity * 2 as i64;
            }
            self.data = realloc(self.data as *u8, new_capacity as u64 * size_of_t as u64) as *T;

            self.capacity = new_capacity;
        }
        self.data[self.length] = value;
        self.length = self.length + 1 as i64;
    }

//    fn [](index : i32) : T {
//        if index < 0 or index >= length {
//            panic("Index out of bounds");
//        }
//        return data[index];
//    }

    fn set(self: mut &array<T>,index : i64, value : T) : void {
        if index < 0 as i64 or index >= self.length {
            panic("Index out of bounds" as *u8);
        }
        self.data[index ] = value;
    }

    fn pop(self: mut &array<T>) : T {
        if self.length == 0 as i64 {
            panic("Pop from empty array" as *u8);
        }
        self.length = self.length - 1 as i64;
        return self.data[self.length];
    }
    fn get(self: &array<T>,index : i64) : T {
        if index < 0 as i64 or index >= self.length {
            panic("Index out of bounds" as *u8);
        }

        let value: T = self.data[index];
        return value;
    }

    fn clear(self: mut &array<T>) : void {
        self.length = 0 as i64;
    }

    fn destroy(self: mut &array<T>) : void {
        core::libc::free(self.data as *u8);
        self.data = null as *T;
        self.length = 0 as i64;
        self.capacity = 0 as i64;
        self = null as *array<T>;
    }
}

fn new_array<T>() : array<T> {
    return array<T> { data: null, length: 0, capacity: 0 };
}