use core::libc;
use core::utils;
use std::math;

struct string {
    pub data : *u8, // Pointer to the string data
    pub length : i32, // Length of the string
    pub capacity : i32, // Capacity of the string

    pub fn as_c_str(self : &string) : *u8 {
        return self.data;
    }
    pub fn length(self : &string) : u32 {
        return self.length as u32;
    }
    pub fn capacity(self : &string) : u32 {
        return self.capacity as u32;
    }
    fn increase_capacity(self : mut &string, new_length : i32) : void {
        if new_length + 1 > self.capacity {
            // Need to reallocate
            let mut new_capacity : i32 = self.capacity * 2;
            if new_capacity < new_length + 1 {
                new_capacity = new_length + 1;
            }
            self.data  = core::libc::realloc(self.data as *u8, new_capacity as u64);
            self.capacity = new_capacity;
        }
    }

    pub fn append(self : mut &string, ch : u8) : void {
        let new_length : i32 = self.length + 1;
        self.increase_capacity(new_length);
        // Append the new character
        self.data[self.length] = ch;
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }
    pub fn append(self : mut &string, other : &string) : void {
        let new_length : i32 = self.length + other.length;
        self.increase_capacity(new_length);
        // Append the new data
        let target : *u8 = self.data + self.length as *u8;
        core::libc::memcpy(target, other.data, other.length as u64);
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }
    pub fn append(self : mut &string, other : string) : void {
        let new_length : i32 = self.length + other.length;
        self.increase_capacity(new_length);
        // Append the new data
        let target : *u8 = self.data + self.length as *u8 ;
        core::libc::memcpy(target, other.data, other.length as u64);
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }
    pub fn append(self : mut &string, number : i32) : void {
        let mut num_str : string = int_to_str(number);
        self.append(&num_str);
        num_str.destroy();
    }

     pub fn append(self : mut &string, number : float) : void {
        let mut num_str1 : string = float_to_str(number);
        self.append(&num_str1);
        num_str1.destroy();
     }

    pub fn append(self : mut &string, number : double) : void {
        let mut num_str2 : string = double_to_str(number);
        self.append(&num_str2);
        num_str2.destroy();
    }
    pub fn append(self : mut &string, other : [u8]) : void {
        let new_length : i32 = self.length + other.length as i32 ;
        self.increase_capacity(new_length);
        // Append the new data
        let _target : *u8 = self.data + self.length as *u8;
        core::libc::memcpy(_target, other.data, other.length as u64);
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }

    pub fn as_slice(self : &string) : [u8] {
        let mut slice : [u8];
        slice.data = self.data;
        slice.length = self.length as u64;
        return slice;
    }

    pub fn __eq__(self : &string, other : string) : bool {
        if self.length != other.length {
            return false;
        }
        for i in 0 .. self.length {
            if self.data[i] != other.data[i] {
                return false;
            }
        }
        return true;
    }

    pub fn destroy(self : mut &string) : void {
        if self.data != 0 as *u8 {
            core::libc::free(self.data);
        }
        // Optionally, you can set fields to zero to avoid dangling pointers
        self.data = 0 as *u8;
        self.length = 0;
        self.capacity = 0;
    }

    pub fn get(self : &string, index : i32) : u8 {
        if index < 0 or index >= self.length {
            panic("Index out of bounds");
            return 0 as u8;
        }
        return self.data[index];
    }

    pub fn set(self : mut &string, index : i32, value : u8) : void {
        if index < 0 or index >= self.length {
            panic("Index out of bounds");
            return;
        }
        self.data[index] = value;
    }


    pub fn replace(self : &string, old : [u8], new : &string) : string {
        let old_length : i32 = old.length as i32;

        for i in 0 .. (self.length - old_length + 1) {
            let mut match_found : bool = true;
            for j in 0 .. old_length {
                let index : i32= i + j;

                if index >= self.length {
                    match_found = false;
                    break;
                }

                if  self.data[index] != old.data[j] {
                    match_found = false;
                    break;
                }
            }
            if match_found {

                // Create prefix and suffix strings
                let mut prefix : string;
                prefix.length = i;
                prefix.capacity = i + 1;
                prefix.length = i;

                prefix.data = core::libc::malloc(prefix.capacity as u64);
                core::libc::memcpy(prefix.data, self.data, prefix.length as u64);
                prefix.data[i] = 0 as u8; // Null-terminate
                prefix.length = i;

                let mut suffix : string;
                suffix.length = self.length - (i + old_length);
                suffix.capacity = suffix.length + 1;
                suffix.data = null as *u8;

                if suffix.length > 0 {
                    suffix.data = core::libc::malloc(suffix.capacity as u64);
                    // copy data to suffix

                    if suffix.data == 0 as *u8 {
                        // Handle memory allocation failure
                        suffix.data = 0 as *u8;
                        suffix.length = 0;
                        suffix.capacity = 0;
                        return suffix; // or handle error appropriately
                    }
                    let suffix_start : *u8 = self.data + i as *u8+ old_length as *u8;
                    // Only copy if there's something to copy
                    core::libc::memcpy(suffix.data, suffix_start, suffix.length as u64);
                    suffix.data[suffix.length] = 0 as u8; // Null-terminate
                }
                let mut result : string = concat(&prefix, new);

                let mut final_result : string = concat(&result, &suffix);


                // Free temporary strings
                prefix.destroy();
                //core::libc::free(suffix.data);
                result.destroy();

                return final_result;

            }
        }
        // If no match found, return a copy of the original string
        return copy(self);
    }
}

pub fn from_c_str(cstr: *u8) : string {
    let mut str_obj : string;// = {data: 0 as *u8, length: 0, capacity: 0};
    str_obj.length  = core::libc::strlen(cstr) as i32;
    str_obj.capacity = str_obj.length + 1;

    str_obj.data = core::libc::malloc(str_obj.capacity as u64);
    core::libc::strcpy(str_obj.data, cstr);


    return str_obj;
}

pub fn from_slice(cstr: [u8]) : string {
    let mut str_obj : string;// = {data: 0 as *u8, length: 0, capacity: 0};
    str_obj.length  = cstr.length as i32;
    str_obj.capacity = str_obj.length + 1;

    str_obj.data = core::libc::malloc(str_obj.capacity as u64);
    core::libc::strcpy(str_obj.data, cstr.data);


    return str_obj;
}






pub fn concat(a : &string, b : &string) : string {
    if(a.length == 0) {
        return copy(b);
    }
    if(b.length == 0) {
        return copy(a);
    }
    let  new_length : i32 = a.length + b.length;
    let mut new_data : *u8 = core::libc::malloc(new_length as u64 + 1  as u64);
    if new_data == 0 as *u8 {
        printf("Memory allocation failed in concat\n" as *u8);
        let mut empty_str : string;
        return empty_str;
    }
    let target : *u8 = new_data + a.length as *u8;
    core::libc::memcpy(new_data, a.data, a.length as u64);
    core::libc::memcpy(target, b.data, b.length as u64);
    new_data[new_length] = 0 as u8; // Null-terminate
    let mut new_str : string;
    new_str.data = new_data;
    new_str.length = new_length;
    new_str.capacity = new_length + 1;
    return new_str;
}

pub fn copy(self : &string) : string {
    let mut copy_str : string;
    copy_str.data = core::libc::malloc(self.capacity as u64);
    if copy_str.data == 0 as *u8 {
        // Handle memory allocation failure
        copy_str.data = 0 as *u8;
        copy_str.length = 0;
        copy_str.capacity = 0;
        return copy_str;
    }
    core::libc::strcpy(copy_str.data, self.data);
    copy_str.length = self.length;
    copy_str.capacity = self.capacity;
    return copy_str;
}
// Converts an integer to string
pub fn char(value : i32) : u8 {
    return value as u8+ '0';
}


// Converts a float to string with N decimal places
pub fn float_to_str(value : float) : string {
    return double_to_str(value as double);
}

pub fn double_to_str(value : double) : string {
    let mut whole : i32 = value as i32;
    let mut frac_part : double = abs(value  - (whole as double));
    let mut resultx : string = string { data: core::libc::malloc(12 as u64), length: 0, capacity: 12 };
    let mut whole_str : string = int_to_str(whole);
    resultx.append(whole_str.as_slice());
    resultx.append( '.' as u8 );

    frac_part = frac_part * 10.0;
    let tmp : double = (value - whole as double) * 1000000000.0;
    let frac : u64 = tmp as u64;
    let mut frac_str : string = int_to_str(frac as i32);
    resultx.append(&frac_str);

    frac_str.destroy();
    whole_str.destroy();



    return resultx;
}

pub fn int_to_str(value : i32) : string {
    let mut digits : string = string { data: core::libc::malloc(12 as u64), length: 0, capacity: 12 };

    if value == 0 {
        digits.append('0' as u8);
        return digits;
    }
    let mut is_negative : bool = false;
    let mut num : i32 = value;
    if num < 0 {
        is_negative = true;
        //num = -num;
        num = 0 - num;
    }
    while num > 0 {
        let digit : i32 = num % 10;
        digits.append( char(digit) );

        num = num / 10;
    }
    if is_negative {
        digits.append( '-' as u8 );
    }
    // Reverse the digits
    let mut start : i32 = 0;
    let mut end : i32 = digits.length - 1;
    while start < end {
        let temp : u8 = digits.get(start);
        digits.set(start, digits.get(end));
        digits.set(end,temp);
        start = start + 1;
        end = end - 1;
    }
    return digits;
}

pub fn str_to_int(s : [u8]) : i32 {
    let mut result : i32 = 0;
    let mut is_negative : bool = false;
    let mut start_index : u64 = 0 as u64;

    if s.length == 0 as u64 {
        return 0; // Handle empty string
    }

    if s.data[0] == '-' as u8 {
        is_negative = true;
        start_index = 1 as u64;
    }

    for ii in start_index .. s.length {
        let ch : u8 = s.data[ii];
        if ch < '0' as u8 or ch > '9' as u8 {
            break; // Stop parsing on non-digit character
        }
        let digit : i32 = (ch - '0' as u8) as i32;
        result = result * 10 + digit;
    }


    if is_negative {
        result = 0 - result;
    }

    return result;
}

pub fn str_to_bool(s : [u8]) : bool {
    if s.length == 4 as u64 {
        if s.data[0] == 't' as u8 and s.data[1] == 'r' as u8 and s.data[2] == 'u' as u8 and s.data[3] == 'e' as u8 {
            return true;
        }
    }
    return false;
}

pub fn str_to_double(s : [u8]) : double {
    let mut result : double = 0.0 as double;
    let mut is_negative : bool = false;
    let mut start_index : u64 = 0 as u64;
    let mut decimal_found : bool = false;
    let mut decimal_place : double = 0.1 as double;

    if s.length == 0 as u64 {
        return 0.0 as double; // Handle empty string
    }

    if s.data[0] == '-' as u8 {
        is_negative = true;
        start_index = 1 as u64;
    }

    for i2 in start_index .. s.length {
        let ch : u8 = s.data[i2];
        if ch == '.' as u8 {
            decimal_found = true;
            continue;
        }
        if ch < '0' as u8 or ch > '9' as u8 {
            break; // Stop parsing on non-digit character
        }
        let digit : i32 = (ch - '0' as u8) as i32;

        if not decimal_found {
            result = result * 10.0 as double + (digit as double);
        } else {
            result = result + (digit as double) * decimal_place;
            decimal_place = decimal_place * 0.1 as double;
        }
    }
    if is_negative {
        result = 0.0 as double - result;
    }
    return result;
}