use core::libc;



struct string {
    data : *u8, // Pointer to the string data
    length : i32, // Length of the string
    capacity : i32, // Capacity of the string

    fn as_c_str(self : &string) : *u8 {
        return self.data;
    }
    fn length(self : &string) : u32 {
        return self.length as u32;
    }
    fn capacity(self : &string) : u32 {
        return self.capacity as u32;
    }
    fn increase_capacity(self : mut &string, new_length : i32) : void {
        if new_length + 1 > self.capacity {
            // Need to reallocate
            let mut new_capacity : i32 = self.capacity * 2;
            self.data  = core::libc::realloc(self.data as *u8, new_capacity as u64);
            self.capacity = new_capacity;
        }
    }

    fn append(self : mut &string, ch : u8) : void {
        let new_length : i32 = self.length + 1;
        self.increase_capacity(new_length);
        // Append the new character
        self.data[self.length] = ch;
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }

    fn append(self : mut &string, other : &string) : void {
        let new_length : i32 = self.length + other.length;
        self.increase_capacity(new_length);
        // Append the new data
        let target : *u8 = self.data + self.length as *u8;
        core::libc::memcpy(target, other.data, other.length as u64);
        self.length = new_length;
        self.data[self.length] = 0 as u8; // Null-terminate
    }
}

fn from_c_str(cstr: *u8) : string {
    let mut str_obj : string;// = {data: 0 as *u8, length: 0, capacity: 0};
    str_obj.length  = core::libc::strlen(cstr) as i32;
    str_obj.capacity = str_obj.length + 1;

    str_obj.data = core::libc::malloc(str_obj.capacity as u64);
    core::libc::strcpy(str_obj.data, cstr);


    return str_obj;
}

fn from_slice(cstr: [u8]) : string {
    let mut str_obj : string;// = {data: 0 as *u8, length: 0, capacity: 0};
    str_obj.length  = cstr.length as i32;
    str_obj.capacity = str_obj.length + 1;

    str_obj.data = core::libc::malloc(str_obj.capacity as u64);
    core::libc::strcpy(str_obj.data, cstr.data);


    return str_obj;
}

fn destroy(self : mut &string) : void {
    if self.data != 0 as *u8 {
        core::libc::free(self.data);
    }
    // Optionally, you can set fields to zero to avoid dangling pointers
    self.data = 0 as *u8;
    self.length = 0;
    self.capacity = 0;
}


fn replace(self : &string, old : [u8], new : &string) : string {
    let old_length : i32 = old.length as i32;

    for i in 0 .. (self.length - old_length + 1) {
        let mut match_found : bool = true;
        for j in 0 .. old_length {
            let index : i32= i + j;

            if index >= self.length {
                match_found = false;
                break;
            }

            if  self.data[index] != old.data[j] {
                match_found = false;
                break;
            }
        }
        if match_found {

            // Create prefix and suffix strings
            let mut prefix : string;
            prefix.length = i;
            prefix.capacity = i + 1;
            prefix.length = i;

            prefix.data = core::libc::malloc(prefix.capacity as u64);
            core::libc::memcpy(prefix.data, self.data, prefix.length as u64);
            prefix.data[i] = 0 as u8; // Null-terminate
            prefix.length = i;

            let mut suffix : string;
            suffix.length = self.length - (i + old_length);
            suffix.capacity = suffix.length + 1;
            suffix.data = null as *u8;

            if suffix.length > 0 {
                suffix.data = core::libc::malloc(suffix.capacity as u64);
                // copy data to suffix

                if suffix.data == 0 as *u8 {
                    // Handle memory allocation failure
                    suffix.data = 0 as *u8;
                    suffix.length = 0;
                    suffix.capacity = 0;
                    return suffix; // or handle error appropriately
                }
                let suffix_start : *u8 = self.data + i as *u8+ old_length as *u8;
                // Only copy if there's something to copy
                core::libc::memcpy(suffix.data, suffix_start, suffix.length as u64);
                suffix.data[suffix.length] = 0 as u8; // Null-terminate
            }
            let mut result : string = concat(&prefix, new);

            let mut final_result : string = concat(&result, &suffix);


            // Free temporary strings
            core::libc::free(prefix.data);
            //core::libc::free(suffix.data);
            core::libc::free(result.data);

            return final_result;

        }
    }
    // If no match found, return a copy of the original string
    return copy(self);
}



fn concat(a : &string, b : &string) : string {
    if(a.length == 0) {
        return copy(b);
    }
    if(b.length == 0) {
        return copy(a);
    }
    let  new_length : i32 = a.length + b.length;
    let mut new_data : *u8 = core::libc::malloc(new_length as u64 + 1  as u64);
    if new_data == 0 as *u8 {
        printf("Memory allocation failed in concat\n" as *u8);
        // Handle memory allocation failure
        let mut empty_str : string;
        empty_str.data = 0 as *u8;
        empty_str.length = 0;
        empty_str.capacity = 0;
        return empty_str;
    }
    let target : *u8 = new_data + a.length as *u8;
    core::libc::memcpy(new_data, a.data, a.length as u64);
    core::libc::memcpy(target, b.data, b.length as u64);
    new_data[new_length] = 0 as u8; // Null-terminate
    let mut new_str : string;
    new_str.data = new_data;
    new_str.length = new_length;
    new_str.capacity = new_length + 1;
    return new_str;
}

fn copy(self : &string) : string {
    let mut copy_str : string;
    copy_str.data = core::libc::malloc(self.capacity as u64);
    if copy_str.data == 0 as *u8 {
        // Handle memory allocation failure
        copy_str.data = 0 as *u8;
        copy_str.length = 0;
        copy_str.capacity = 0;
        return copy_str;
    }
    core::libc::strcpy(copy_str.data, self.data);
    copy_str.length = self.length;
    copy_str.capacity = self.capacity;
    return copy_str;
}
// Converts an integer to string
fn char(value : i32) : u8 {
    return value as u8+ '0';
}

fn abs(value : double) : double {
    if value < 0.0 as double {
        return 0.0 as double - value;
    }
    return value;
}

// Converts a float to string with N decimal places
fn float_to_str(value : float) : string {
    return double_to_str(value as double);
}

fn double_to_str(value : double) : string {
    let mut whole : i32 = value as i32;
    let mut frac_part : double = abs(value  - (whole as double));
    let mut result : string = int_to_str(whole);
    result.append( '.' as u8 );

    //printf(r"frac_part: %f\n" as *u8, frac_part);
    frac_part = frac_part * 10.0;
    let tmp : double = (value - whole as double) * 1000000000.0;
    let frac : u64 = tmp as u64;
    let mut frac_str : string = int_to_str(frac as i32);
    result.append(&frac_str);

    destroy(&frac_str);


    return result;
}

fn int_to_str(value : i32) : string {
    if value == 0 {
        return "0";
    }
    let mut is_negative : bool = false;
    let mut num : i32 = value;
    if num < 0 {
        is_negative = true;
        //num = -num;
        num = 0 - num;
    }
    let mut digits : string = string { data: core::libc::malloc(12 as u64), length: 0, capacity: 12 };
    while num > 0 {
        let digit : i32 = num % 10;
        digits.append( char(digit) );

        num = num / 10;
    }
    if is_negative {
        digits.append( '-' as u8 );
    }
    // Reverse the digits
    let mut start : i32 = 0;
    let mut end : i32 = digits.length - 1;
    while start < end {
        let temp : u8 = digits.data[start];
        digits.data[start] = digits.data[end];
        digits.data[end] = temp;
        start = start + 1;
        end = end - 1;
    }
    return digits;
}
